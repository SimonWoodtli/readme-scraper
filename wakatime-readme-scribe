#!/usr/bin/bash
source api-key #Temporary for testing the script
# dependencies: bash, sed, jq, printf, ed

_main() {
  local preTemplateFile="$PWD/templates/preTemplateReadme.md.tpl"
  local templateFile="$PWD/templates/README.md.tpl"
  local fetchWakaData
  fetchWakaData=$(curl https://wakatime.com/api/v1/users/current/stats/last_7_days?api_key="$wakaKey" | jq '.')
  ## Find all the html comment tags and put them in an array. 
  local -a findComments=( "anguages" "editors" "os" "projects" "timezone")
  local -a foundComments=()
  local -i checkCommentStartLine
  local -i checkCommentEndLine

  ## Loop over all possible comments from findComments and check if they
  ## can be found in preTemplateFile, if yes add them to foundComments
  for findComment in "${findComments[@]}"; do
    checkCommentStartLine=$(grep -n '<!--'"$findComment"'-start-->' "$preTemplateFile" | cut --characters=1,2)
    checkCommentEndLine=$(grep -n '<!--'"$findComment"'-end-->' "$preTemplateFile" | cut --characters=1,2)
    if [[ $checkCommentStartLine -ne 0 && $checkCommentEndLine -ne 0 ]]; then
      foundComments+=( "$findComment" )
    fi
  done
  [[ -n $foundComments ]] || exit 1

  _fetchDataLanguages
}

_fetchDataLanguages() {
  ## create variables and arrays
  local languagesName
  local languagesPercent
  local languagesText
  local languagesNameLines
  local languagesPercentLines
  local languagesTextLines
  local -a languagesNameArray=()
  local -a languagesPercentArray=()
  local -a languagesTextArray=()
  ## TODO make _fetchDataLanguages to generic _fetchData and grab all the
  ## data strings that are defined in the comment array
  ## For precise processing and printing an array is more useful than just having all
  ## the data for each language in a variable
  
  ## TODO If it can't find any data because the user was inactive make
  ## sure a inactive() function gets triggered that prints this inactivity
  ## Fetch data as strings per line in a variable
  languagesName=$(echo "$fetchWakaData" | jq -r '.data.languages | .[] | .name')
  languagesPercent=$(echo "$fetchWakaData" | jq -r '.data.languages | .[] | .percent')
  languagesText=$(echo "$fetchWakaData" | jq -r '.data.languages | .[] | .text')
  ## Get the total number of lines for each variable
  ## Since each collection contains the "text" key-value pair it is
  ##sufficient to only tackle the total number of lines from one key-value
  ##pair
  languagesNameLines=$(echo "$languagesName" | wc -l)
  languagesPercentLines=$(echo "$languagesPercent" | wc -l)
  languagesTextLines=$(echo "$languagesText" | wc -l)
  [[ "$languagesNameLines" == "$languagesPercentLines" && "$languagesNameLines" == "$languagesTextLines" ]] || exit 2
  ## Fill up the empty arrays while looping over the total amount of
  ##lines
  for ((i = 0 ; i < "$languagesTextLines" ; i++)); do
    languagesNameArray+=( "$(echo "$fetchWakaData" | jq -r ".data.languages | .[$i] | .name")" )
    languagesPercentArray+=( "$(echo "$fetchWakaData" | jq -r ".data.languages | .[$i] | .percent")" )
    languagesTextArray+=( "$(echo "$fetchWakaData" | jq  -r ".data.languages | .[$i] | .text")" )
  done
  _printDataLanguages
  #echo ${languagesTextArray[@]}
  #echo ${languagesTextArray[0]}
}
_printDataLanguages() {
  ## TODO make _printDataLanguages to generic _printData and print all the
  ## Data strings that are defined in the comment array
  local languagesHtmlBlock='<h4>ðŸ”¥ Languages:</h4>'
  #local backslash="\\\"
  for ((i = 0 ; i < "$languagesTextLines" ; i++)); do
    #echo $i
    languagesHtmlBlock+='
<span>'"${languagesNameArray[$i]}"'</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>'"${languagesTextArray[$i]}"'</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>'"${languagesPercentArray[$i]}%"'</span>'
  done
  ##SOLUTION!!! https://stackoverflow.com/questions/67929263/inserting-contents-of-one-text-file-into-another-in-bash
  ## Im no't too proud for having to use a buffer file, but sed with multi
  #line strings is a pain, and learning perl takes too much time -> gotta finish this project!
  ##TODO Maybe I can use the mktemp command to create a temp file gotta
  ## figure out once this is in a docker container
  echo "$languagesHtmlBlock" > buffer
  ## Add new api content to preTemplateFile
  printf "%s\n" "/<!--languages-start-->/r buffer" w  | ed -s "$preTemplateFile"
  ## Update new api content into templateFile
  cat "$preTemplateFile" > "$templateFile"
  _cleanUpBuffer
  _cleanUpTemplates
}

_cleanUpTemplates() {
  ## Function to edit templateFile (remove html comment) and preTemplateFile (remove content)
  ## store line number from start/end tag
  local -i findCommentStartLine
  local -i findCommentEndLine
  
  ## Loop over comment array and for earch comment
  for foundComment in "${foundComments[@]}"; do
    # Grab html comment start and finish line number
    #echo $foundComment
    findCommentStartLine=$(grep -n '<!--'"$foundComment"'-start-->' "$preTemplateFile" | cut --characters=1,2)
    findCommentEndLine=$(grep -n '<!--'"$foundComment"'-end-->' "$preTemplateFile" | cut --characters=1,2)
    ## If findCommentStartLine gives back 0 skip sed commands
    if [[ $findCommentStartLine -ne 0 && $findCommentEndLine -ne 0 ]]; then
      ## Delete html comment tags from templateFile
      sed -i "${findCommentStartLine}d;${findCommentEndLine}d" "$templateFile"
      ## Adjust num to match content
      ((findCommentStartLine=findCommentStartLine+1))
      ((findCommentEndLine=findCommentEndLine-1))
      ## Delete content between html comment tags from preTemplateFile
      sed -i "$findCommentStartLine,${findCommentEndLine}d" "$preTemplateFile"
    fi
  done
}

_cleanUpBuffer() {
  ## TODO Find a better command to clean buffer file
  echo "" > "$PWD/buffer"
}

_main

## Remember: Variables and sed are a bit tricky. Don't quote variables that have spaces!
#https://stackoverflow.com/questions/49461777/sed-with-variables-and-spaces
##TODO ADDITIONAL: Add the github api and have some queries about github stats: replace all the functions I currently fetch via readme-scribe
## add another github api request to show which github repos are written in
#which language an list them according to the language that is no.1 in most repos -> language/repo

##TODO The idea for this repo is that a persons github profile repo should be setup with a
##github action that runs this wakatime-stats repo and this bash script gets
##executed
##TODO How to get githubs secret repo env variables into bash variable?
##I guess it is just a normal exported env. variable so this might
##actually work
##The user would need to set a github action secret from the profile
##repos settings and name it 'WAKATIME_API_KEY'
##TODO How to get jq installed on ubunut-latest from github action? => use
##docker
#declare wakaKey="$WAKATIME_API_KEY"
##TODO The current templates/files are used for testing, later when I
##I got a docker image and github action I need to implement it in this
##script so that it actually targets the files in the github profile
##TODO Use jq to get all the data, for every title with some stats that
##you fetch from wakas api like:
## Editors, Languages etc. now have a env. variable that people have to place
## in their preTemplatesReadme.md.tpl wherever they see fit
##TODO Create docker image on hub.docker.com that uses the env. I need to
##be able to run wakatime-stats
##TODO Create github action that gets listed on marketplace, I guess?
##Write README.md on how to configure and setup this repo to be able to
##use it
##TODO Since readme-scribe already uses a template and I can't add
##any hidden comments because readme-scribe will delete them when it runs.
##Which in turn willl make direct changes from this script on the readme-scribe template
##impossible.
##My idea is to have a pre-template which than writes and updates the
##readme-scribe template which than runs and updates the real README.md
##define the pre-template.
